<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MC Compiler: README</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MC Compiler
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="http://www.jonathanbeard.io/tutorials/FlexBisonC++">http://www.jonathanbeard.io/tutorials/FlexBisonC++</a></p>
<hr/>
<h3>Notes before getting started</h3>
<p>To compile the example located on <a href="https://github.com/jonathan-beard/simple_wc_example">GitHub</a> you'll need a few things. First, you'll need the <a href="http://flex.sourceforge.net/">Flex</a> utility. Some systems come with it pre-installed with developer or build tools, but you'll need to make sure that it is a relatively recent version (e.g., 2.5.37). One issue that might arise for Apple users is an incompatible version of Flex. The default installed version is 2.5.35 (Apple provided), however the header file that is included won't work with this example. One solution is changing the example, however that will make it incompatible with any recent version of Flex. A better solution is simply to upgrade Flex to a newer version. For more information on this issue for Apple users, <a href="http://lmgtfy.com/?q=FlexLexer.h+header+file+on+OS+X">LMGTFY</a>.</p>
<h3>The Flex Scanner</h3>
<p>How the Flex scanner itself works is beyond the scope of this tutorial. There are plenty of references on how to get started with a scanner, especially in C. There are lots of other examples out there but I found that most require quite a bit of work to get going and are far from complete. I based the example on some other Flex/Bison examples that create something similar to the Unix word count utility (<em>wc</em>). The language I used differs slightly from <em>wc</em> in the following respects: words are only alpha characters, numbers are simply counted as characters and I count upper and lower case characters.</p>
<h3>The Flex Scanner Code</h3>
<div class="fragment"><div class="line">%{</div><div class="line"><span class="comment">/* C++ string header, for string ops below */</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="comment">/* Implementation of yyFlexScanner */</span> </div><div class="line"><span class="preprocessor">#include &quot;mc_scanner.hpp&quot;</span></div><div class="line"><span class="preprocessor">#undef  YY_DECL</span></div><div class="line"><span class="preprocessor">#define YY_DECL int MC::MC_Scanner::yylex( MC::MC_Parser::semantic_type * const lval, MC::MC_Parser::location_type *location )</span></div><div class="line"></div><div class="line"><span class="comment">/* using &quot;token&quot; to make the returns for the tokens shorter to type */</span></div><div class="line"><span class="keyword">using</span> <a class="code" href="../../dd/d8d/struct_m_c_1_1_m_c___parser_1_1token.html">token</a> = <a class="code" href="../../d4/d77/scanner_8cpp.html#a819340f5252b9ee44debdc060f47dbc8">MC::MC_Parser::token</a>;</div><div class="line"></div><div class="line"><span class="comment">/* define yyterminate as this instead of NULL */</span></div><div class="line"><span class="preprocessor">#define yyterminate() return( token::END )</span></div><div class="line"></div><div class="line"><span class="comment">/* msvc2010 requires that we exclude this header file. */</span></div><div class="line"><span class="preprocessor">#define YY_NO_UNISTD_H</span></div><div class="line"></div><div class="line"><span class="comment">/* update location on matching */</span></div><div class="line"><span class="preprocessor">#define YY_USER_ACTION loc-&gt;step(); loc-&gt;columns(yyleng);</span></div><div class="line"></div><div class="line">%}</div><div class="line"></div><div class="line">%option debug</div><div class="line">%option nodefault</div><div class="line">%option yyclass=<span class="stringliteral">&quot;MC::MC_Scanner&quot;</span></div><div class="line">%option noyywrap</div><div class="line">%option c++</div><div class="line"></div><div class="line">%%</div><div class="line">%{          </div><div class="line">            <a class="code" href="../../d4/d77/scanner_8cpp.html#af8702f09f01285d3777507e641f94463">yylval</a> = lval;</div><div class="line">%}</div><div class="line"></div><div class="line">[a-z]       {</div><div class="line">               <span class="keywordflow">return</span>( token::LOWER );</div><div class="line">            }</div><div class="line"></div><div class="line">[A-Z]       {</div><div class="line">               <span class="keywordflow">return</span>( token::UPPER );</div><div class="line">            }</div><div class="line"></div><div class="line">[a-zA-Z]+   {</div><div class="line">               <a class="code" href="../../d4/d77/scanner_8cpp.html#af8702f09f01285d3777507e641f94463">yylval</a>-&gt;build&lt; std::string &gt;( yytext );</div><div class="line">               <span class="keywordflow">return</span>( token::WORD );</div><div class="line">            }</div><div class="line"></div><div class="line">\n          {</div><div class="line">               loc-&gt;lines();</div><div class="line">               <span class="keywordflow">return</span>( token::NEWLINE );</div><div class="line">            }</div><div class="line"></div><div class="line">.           {</div><div class="line">               <span class="keywordflow">return</span>( token::CHAR );</div><div class="line">            }</div><div class="line">%%</div></div><!-- fragment --><p>A brief explanation of the scanner file</p>
<p>On line 3 the C++ string header file is included since we use it within this code. The scanner header file (line 6) is included, which we'll talk about next, extends yyFlexLexer found in FlexLexer.h. This is the scanner class itself. Next you'll see a using statement included simply to make the namespacing a bit shorter to type when returning tokens. In previous versions of this tutorial I'd added a macro to create actual string objects from the char string yytext. Bison now defines a template function to cast/create the proper objects for you, so this version of the tutorial uses this more modern construct. If you're interested in the details, see the Bison documenation (direct link). In the past you would manually have to define your own union. Now that is largely done for you based on the token types which is much nicer. On line 7 you'll want to notice that the yylex function that is defined in the mc_scanner.hpp header file is declared as a #define with YY_DECL. This function signature must match that one (minus the virtual or other class header keywords). This is extremely important, otherwise you will hit this section within the generated code, and get the default <a class="el" href="../../db/d8b/parser_8tab_8cpp.html#a5611300548b2030d86b6ab9168132b88">yylex()</a> function (discussed in detail later).</p>
<p>On line 14 you'll notice that I've defined terminate, I would like it to be a token type instead of NULL so we define it before the code below is read (from the generated file). This way <a class="el" href="../../d4/d77/scanner_8cpp.html#ac3286b18a2e91b4571b97df96a118e84">yyterminate()</a> is already defined by the time the compiler reaches this point in the generated code so our version is in the compiled code and not the default one.</p>
<div class="fragment"><div class="line"><span class="comment">/* No semi-colon after return; correct usage is to write &quot;yyterminate();&quot; -</span></div><div class="line"><span class="comment"> * we don&#39;t want an extra &#39;;&#39; after the &quot;return&quot; because that will cause</span></div><div class="line"><span class="comment"> * some compilers to complain about unreachable statements.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="preprocessor">#ifndef yyterminate</span></div><div class="line"><span class="preprocessor">#define yyterminate() return YY_NULL</span></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>Next you'll see that there are several options selected. Most of these are self explanatory or are explained within the Flex documentation, however the one's you don't want to miss are the nodefault, yyclass=, noyywrap and c++ options. The yyclass option indicates what the scanner class is actually called. This is the same class that is imported on line 3.</p>
<h2>**The Scanner Class Definition** </h2>
<div class="fragment"><div class="line">ifndef MCSCANNER_HPP</div><div class="line"></div><div class="line">define MCSCANNER_HPP 1</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> ! defined(yyFlexLexerOnce)</div><div class="line"></div><div class="line">include &lt;FlexLexer.h&gt;</div><div class="line"></div><div class="line">endif</div><div class="line"></div><div class="line">include <span class="stringliteral">&quot;mc_parser.tab.hh&quot;</span></div><div class="line"></div><div class="line">include <span class="stringliteral">&quot;location.hh&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="../../d4/d73/namespace_m_c.html">MC</a>{</div><div class="line"></div><div class="line"><span class="keyword">class </span>MC_Scanner : <span class="keyword">public</span> <a class="code" href="../../d4/d77/scanner_8cpp.html#af699458ba5331ddec7e15a878f42f8f5">yyFlexLexer</a>{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1f/class_m_c_1_1_m_c___scanner.html#ad7c137d9cc294a94ac72da3134982bb2">MC_Scanner</a>(std::istream *in) : <a class="code" href="../../d4/d77/scanner_8cpp.html#af699458ba5331ddec7e15a878f42f8f5">yyFlexLexer</a>(in)</div><div class="line">{</div><div class="line">loc = <span class="keyword">new</span> <a class="code" href="../../db/d59/class_m_c_1_1_m_c___parser.html#a337925512acbb9d87014fe18569b51a6">MC::MC_Parser::location_type</a>();</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">//get rid of override virtual function warning</span></div><div class="line"><span class="keyword">using</span> <a class="code" href="../../db/d8b/parser_8tab_8cpp.html#a5611300548b2030d86b6ab9168132b88">FlexLexer::yylex</a>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="../../de/d1f/class_m_c_1_1_m_c___scanner.html#a9e0acebb8f1118d16ade054993dc60ab">yylex</a>( <a class="code" href="../../d3/d14/class_m_c_1_1_m_c___parser_1_1semantic__type.html">MC::MC_Parser::semantic_type</a> * <span class="keyword">const</span> lval,</div><div class="line"><a class="code" href="../../d5/d32/class_m_c_1_1location.html">MC::MC_Parser::location_type</a> *location );</div><div class="line"><span class="comment">// YY_DECL defined in mc_lexer.l</span></div><div class="line"><span class="comment">// Method body created by flex in mc_lexer.yy.cc</span></div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line"><span class="comment">/* yyval ptr */</span></div><div class="line"><a class="code" href="../../d3/d14/class_m_c_1_1_m_c___parser_1_1semantic__type.html">MC::MC_Parser::semantic_type</a> yylval = <span class="keyword">nullptr</span>;</div><div class="line">/ location ptr */</div><div class="line"><a class="code" href="../../d5/d32/class_m_c_1_1location.html">MC::MC_Parser::location_type</a> *loc = <span class="keyword">nullptr</span>;</div><div class="line">};</div><div class="line"></div><div class="line">} <span class="comment">/* end namespace MC */</span></div><div class="line"></div><div class="line">endif <span class="comment">/* END MCSCANNER_HPP */</span></div></div><!-- fragment --><p>Line 5 simply includes the FlexLexer.h class that defines yyFlexLexer. We then include the bison generated header file which includes the token definitions. The constructor is relatively straight forward, we simply call the yyFlexLexer constructor then we initialize the private yylval pointer to nullptr. The only function that we need to define in this simple example we have yylex which we defined as YY_DECL earlier. One thing to make note of is the fact that <a class="el" href="../../db/d8b/parser_8tab_8cpp.html#a5611300548b2030d86b6ab9168132b88">yylex()</a> is now declared as virtual, and can throw an override error when defining your own function. To get around this, we've added a using statement to ensure the compiler knows that we meant to define a new yylex on line 24. Just to show why we undefined YY_DECL here's a code snippet from the generated <a href="http://lex.yy.cc">lex.yy.cc</a>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef YY_DECL</span></div><div class="line"><span class="preprocessor">#define YY_DECL_IS_OURS 1</span></div><div class="line"><span class="comment">/* %if-c-only Standard (non-C++) definition */</span></div><div class="line"><span class="comment">/* %endif */</span></div><div class="line"><span class="comment">/* %if-c++-only C++ definition */</span></div><div class="line"><span class="preprocessor">#define YY_DECL int yyFlexLexer::yylex()</span></div><div class="line"><span class="comment">/* %endif */</span></div><div class="line"><span class="preprocessor">#endif </span><span class="comment">/* !YY_DECL */</span><span class="preprocessor"></span></div></div><!-- fragment --><p>By defining YY_DECL, we get rid of the native one. That pretty much concludes the scanner portion, on to the parser stuff.</p>
<h2>The Bison C++ Parser File </h2>
<div class="fragment"><div class="line">%skeleton <span class="stringliteral">&quot;lalr1.cc&quot;</span></div><div class="line">%require  <span class="stringliteral">&quot;3.0&quot;</span></div><div class="line">%debug </div><div class="line">%defines </div><div class="line">%define api.namespace {<a class="code" href="../../d4/d73/namespace_m_c.html">MC</a>}</div><div class="line">%define parser_class_name {MC_Parser}</div><div class="line"></div><div class="line">%code requires{</div><div class="line">   <span class="keyword">namespace </span><a class="code" href="../../d4/d73/namespace_m_c.html">MC</a> {</div><div class="line">      <span class="keyword">class </span>MC_Driver;</div><div class="line">      <span class="keyword">class </span>MC_Scanner;</div><div class="line">   }</div><div class="line"></div><div class="line"><span class="comment">// The following definitions is missing when %locations isn&#39;t used</span></div><div class="line"><span class="preprocessor"># ifndef YY_NULLPTR</span></div><div class="line"><span class="preprocessor">#  if defined __cplusplus &amp;&amp; 201103L &lt;= __cplusplus</span></div><div class="line"><span class="preprocessor">#   define YY_NULLPTR nullptr</span></div><div class="line"><span class="preprocessor">#  else</span></div><div class="line"><span class="preprocessor">#   define YY_NULLPTR 0</span></div><div class="line"><span class="preprocessor">#  endif</span></div><div class="line"><span class="preprocessor"># endif</span></div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line">%parse-param { MC_Scanner  &amp;scanner  }</div><div class="line">%parse-param { MC_Driver  &amp;driver  }</div><div class="line"></div><div class="line">%code{</div><div class="line"><span class="preprocessor">   #include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">   #include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">   #include &lt;fstream&gt;</span></div><div class="line">   </div><div class="line">   <span class="comment">/* include for all driver functions */</span></div><div class="line"><span class="preprocessor">   #include &quot;mc_driver.hpp&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#undef yylex</span></div><div class="line"><span class="preprocessor">#define yylex scanner.yylex</span></div><div class="line">}</div><div class="line"></div><div class="line">%define api.value.type variant</div><div class="line">%define parse.assert</div><div class="line"></div><div class="line">%<a class="code" href="../../dd/d8d/struct_m_c_1_1_m_c___parser_1_1token.html">token</a>               END    0     <span class="stringliteral">&quot;end of file&quot;</span></div><div class="line">%<a class="code" href="../../dd/d8d/struct_m_c_1_1_m_c___parser_1_1token.html">token</a>               UPPER</div><div class="line">%<a class="code" href="../../dd/d8d/struct_m_c_1_1_m_c___parser_1_1token.html">token</a>               LOWER</div><div class="line">%<a class="code" href="../../dd/d8d/struct_m_c_1_1_m_c___parser_1_1token.html">token &lt;std::string&gt;</a> WORD</div><div class="line">%<a class="code" href="../../dd/d8d/struct_m_c_1_1_m_c___parser_1_1token.html">token</a>               NEWLINE</div><div class="line">%<a class="code" href="../../dd/d8d/struct_m_c_1_1_m_c___parser_1_1token.html">token</a>               CHAR</div><div class="line"></div><div class="line">%locations</div><div class="line"></div><div class="line">%%</div><div class="line"></div><div class="line">list_option : END | list END;</div><div class="line"></div><div class="line">list</div><div class="line">  : item</div><div class="line">  | list item</div><div class="line">  ;</div><div class="line"></div><div class="line">item</div><div class="line">  : UPPER   { driver.add_upper(); }</div><div class="line">  | LOWER   { driver.add_lower(); }</div><div class="line">  | WORD    { driver.add_word( $1 ); }</div><div class="line">  | NEWLINE { driver.add_newline(); }</div><div class="line">  | CHAR    { driver.add_char(); }</div><div class="line">  ;</div><div class="line"></div><div class="line">%%</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> </div><div class="line"><a class="code" href="../../db/d59/class_m_c_1_1_m_c___parser.html#a7945e9eb5ac00ae86d0714db388fb941">MC::MC_Parser::error</a>( <span class="keyword">const</span> location_type &amp;l, <span class="keyword">const</span> std::string &amp;err_message )</div><div class="line">{</div><div class="line">   std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; err_message &lt;&lt; <span class="stringliteral">&quot; at &quot;</span> &lt;&lt; l &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p>Exactly how to write a language, and express it such that the parser can parse it is definitely beyond the scope of this tutorial, there are plenty of books on how to do this. Here is just a simple description of how to define the C++ parser. The first line declares that we want to use the lalr1 skeleton file (if you want to learn what types of skeletons are available, the documentation does a fairly good job going through them). We then include the required version of Bison (for this example version 3.0+, however you can download an example that works with version 2.5 through 2.7 here: link). There's a bit of new syntax which is the reason for the version differentiation. The debug option is set on line 3. The namespace that we want this parser to use is defined on line 5 along with the parser class on line 6 (Note: its usually a good idea to have a unique namespace and a parser name so when you have multiple parsers they can be kept very distinct). On line 8 the classes that are used within the parser are defined, think of this as a forward declaration. Lines 14 through 21 are included because of a bug (perhaps feature) that removes this definition when locations isn't used. Lines 25 and 26 are important as they define what will be given to the parser when its instantiated and upon calls to yylex. There's quite a few more options that can be given to Bison, some of those for version 3.0 are listed here (Bison Docs). Here's a snippet from the generated parser header to show our parser constructor mc_parser.tab.hh:</p>
<div class="fragment"><div class="line">MC_Parser (MC_Scanner  &amp;scanner_yyarg, MC_Driver  &amp;driver_yyarg);</div></div><!-- fragment --><p>Reference to both the passed in driver and scanner are kept as private members of the parser class. Within the code section we have all the rest of the information that our code will need to compile, include the requisite C++ headers, the driver class that we'll get to shortly. We also define a static yylex function that'll be called within the bison parse function that takes the parameters that were defined on lines 25-26. This function will call the scanner's yylex function, any other behavior need can be defined here. Next we have the simple language which differs from the way the actual wc functions in the manner mentioned in the intro. Last the error function and the static yylex function is defined.</p>
<h2>The Driver Header File </h2>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef __MCDRIVER_HPP__</span></div><div class="line"><span class="preprocessor">#define __MCDRIVER_HPP__ 1</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cstddef&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;istream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;mc_scanner.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;mc_parser.tab.hh&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="../../d4/d73/namespace_m_c.html">MC</a>{</div><div class="line"></div><div class="line"><span class="keyword">class </span>MC_Driver{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">   MC_Driver() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">   <span class="keyword">virtual</span> <a class="code" href="../../d8/dcb/class_m_c_1_1_m_c___driver.html#a1a4bf7e65b94a096cdbabb1bfd377d33">~MC_Driver</a>();</div><div class="line">   </div><div class="line">   <span class="keywordtype">void</span> <a class="code" href="../../d8/dcb/class_m_c_1_1_m_c___driver.html#abe3e374d900420bf84160aed1641217c">parse</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> *filename );</div><div class="line">   <span class="keywordtype">void</span> <a class="code" href="../../d8/dcb/class_m_c_1_1_m_c___driver.html#abe3e374d900420bf84160aed1641217c">parse</a>( std::istream &amp;iss );</div><div class="line"></div><div class="line">   <span class="keywordtype">void</span> add_upper();</div><div class="line">   <span class="keywordtype">void</span> add_lower();</div><div class="line">   <span class="keywordtype">void</span> add_word( <span class="keyword">const</span> std::string &amp;word );</div><div class="line">   <span class="keywordtype">void</span> add_newline();</div><div class="line">   <span class="keywordtype">void</span> add_char();</div><div class="line"></div><div class="line">   std::ostream&amp; <a class="code" href="../../d8/dcb/class_m_c_1_1_m_c___driver.html#ab58c2d21dd6ba7d372863efdb24b181f">print</a>(std::ostream &amp;stream);</div><div class="line"><span class="keyword">private</span>:</div><div class="line"></div><div class="line">   <span class="keywordtype">void</span> parse_helper( std::istream &amp;stream );</div><div class="line"></div><div class="line">   std::size_t  chars      = 0;</div><div class="line">   std::size_t  words      = 0;</div><div class="line">   std::size_t  lines      = 0;</div><div class="line">   std::size_t  uppercase  = 0;</div><div class="line">   std::size_t  lowercase  = 0;</div><div class="line">   <a class="code" href="../../db/d59/class_m_c_1_1_m_c___parser.html">MC::MC_Parser</a>  *parser  = <span class="keyword">nullptr</span>;</div><div class="line">   <a class="code" href="../../de/d1f/class_m_c_1_1_m_c___scanner.html">MC::MC_Scanner</a> *scanner = <span class="keyword">nullptr</span>;</div><div class="line">   </div><div class="line">   <span class="keyword">const</span> std::string red   = <span class="stringliteral">&quot;\033[1;31m&quot;</span>;</div><div class="line">   <span class="keyword">const</span> std::string blue  = <span class="stringliteral">&quot;\033[1;36m&quot;</span>;</div><div class="line">   <span class="keyword">const</span> std::string norm  = <span class="stringliteral">&quot;\033[0m&quot;</span>;</div><div class="line">};</div><div class="line"></div><div class="line">} <span class="comment">/* end namespace MC */</span></div><div class="line"><span class="preprocessor">#endif </span><span class="comment">/* END __MCDRIVER_HPP__ */</span><span class="preprocessor"></span></div></div><!-- fragment --><p>One thing you'll notice is that there are two parse functions. One is to take input from a file, the other for input from a C++ stream. The main function defines paths to take input from a pipe and also via file. This is implemented via these parser functions. The cool thing about having a stream input is that you can also use this to parse command line input if you'd like.</p>
<hr/>
<h2>**The Driver Implementation** </h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cctype&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;mc_driver.hpp&quot;</span></div><div class="line"></div><div class="line"><a class="code" href="../../d8/dcb/class_m_c_1_1_m_c___driver.html#a1a4bf7e65b94a096cdbabb1bfd377d33">MC::MC_Driver::~MC_Driver</a>()</div><div class="line">{</div><div class="line">   <span class="keyword">delete</span>(scanner);</div><div class="line">   scanner = <span class="keyword">nullptr</span>;</div><div class="line">   <span class="keyword">delete</span>(parser);</div><div class="line">   parser = <span class="keyword">nullptr</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> </div><div class="line"><a class="code" href="../../d8/dcb/class_m_c_1_1_m_c___driver.html#abe3e374d900420bf84160aed1641217c">MC::MC_Driver::parse</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> filename )</div><div class="line">{</div><div class="line">   assert( filename != <span class="keyword">nullptr</span> );</div><div class="line">   std::ifstream in_file( filename );</div><div class="line">   <span class="keywordflow">if</span>( ! in_file.good() )</div><div class="line">   {</div><div class="line">       exit( EXIT_FAILURE );</div><div class="line">   }</div><div class="line">   parse_helper( in_file );</div><div class="line">   <span class="keywordflow">return</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line"><a class="code" href="../../d8/dcb/class_m_c_1_1_m_c___driver.html#abe3e374d900420bf84160aed1641217c">MC::MC_Driver::parse</a>( std::istream &amp;stream )</div><div class="line">{</div><div class="line">   <span class="keywordflow">if</span>( ! stream.good()  &amp;&amp; stream.eof() )</div><div class="line">   {</div><div class="line">       <span class="keywordflow">return</span>;</div><div class="line">   }</div><div class="line">   <span class="comment">//else</span></div><div class="line">   parse_helper( stream ); </div><div class="line">   <span class="keywordflow">return</span>;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> </div><div class="line">MC::MC_Driver::parse_helper( std::istream &amp;stream )</div><div class="line">{</div><div class="line">   </div><div class="line">   <span class="keyword">delete</span>(scanner);</div><div class="line">   <span class="keywordflow">try</span></div><div class="line">   {</div><div class="line">      scanner = <span class="keyword">new</span> <a class="code" href="../../de/d1f/class_m_c_1_1_m_c___scanner.html">MC::MC_Scanner</a>( &amp;stream );</div><div class="line">   }</div><div class="line">   <span class="keywordflow">catch</span>( std::bad_alloc &amp;ba )</div><div class="line">   {</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to allocate scanner: (&quot;</span> &lt;&lt;</div><div class="line">         ba.what() &lt;&lt; <span class="stringliteral">&quot;), exiting!!\n&quot;</span>;</div><div class="line">      exit( EXIT_FAILURE );</div><div class="line">   }</div><div class="line">   </div><div class="line">   <span class="keyword">delete</span>(parser); </div><div class="line">   <span class="keywordflow">try</span></div><div class="line">   {</div><div class="line">      parser = <span class="keyword">new</span> <a class="code" href="../../db/d59/class_m_c_1_1_m_c___parser.html">MC::MC_Parser</a>( (*scanner) <span class="comment">/* scanner */</span>, </div><div class="line">                                  (*<span class="keyword">this</span>) <span class="comment">/* driver */</span> );</div><div class="line">   }</div><div class="line">   <span class="keywordflow">catch</span>( std::bad_alloc &amp;ba )</div><div class="line">   {</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to allocate parser: (&quot;</span> &lt;&lt; </div><div class="line">         ba.what() &lt;&lt; <span class="stringliteral">&quot;), exiting!!\n&quot;</span>;</div><div class="line">      exit( EXIT_FAILURE );</div><div class="line">   }</div><div class="line">   <span class="keyword">const</span> <span class="keywordtype">int</span> accept( 0 );</div><div class="line">   <span class="keywordflow">if</span>( parser-&gt;parse() != accept )</div><div class="line">   {</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Parse failed!!\n&quot;</span>;</div><div class="line">   }</div><div class="line">   <span class="keywordflow">return</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> </div><div class="line">MC::MC_Driver::add_upper()</div><div class="line">{ </div><div class="line">   uppercase++; </div><div class="line">   chars++; </div><div class="line">   words++; </div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> </div><div class="line">MC::MC_Driver::add_lower()</div><div class="line">{ </div><div class="line">   lowercase++; </div><div class="line">   chars++; </div><div class="line">   words++; </div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> </div><div class="line">MC::MC_Driver::add_word( <span class="keyword">const</span> std::string &amp;word )</div><div class="line">{</div><div class="line">   words++; </div><div class="line">   chars += word.length();</div><div class="line">   <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keywordtype">char</span> &amp;c : word ){</div><div class="line">      <span class="keywordflow">if</span>( islower( c ) )</div><div class="line">      { </div><div class="line">         lowercase++; </div><div class="line">      }</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( isupper( c ) ) </div><div class="line">      { </div><div class="line">         uppercase++; </div><div class="line">      }</div><div class="line">   }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> </div><div class="line">MC::MC_Driver::add_newline()</div><div class="line">{ </div><div class="line">   lines++; </div><div class="line">   chars++; </div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> </div><div class="line">MC::MC_Driver::add_char()</div><div class="line">{ </div><div class="line">   chars++; </div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line">std::ostream&amp; </div><div class="line"><a class="code" href="../../d8/dcb/class_m_c_1_1_m_c___driver.html#ab58c2d21dd6ba7d372863efdb24b181f">MC::MC_Driver::print</a>( std::ostream &amp;stream )</div><div class="line">{</div><div class="line">   stream &lt;&lt; red  &lt;&lt; <span class="stringliteral">&quot;Results: &quot;</span> &lt;&lt; norm &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">   stream &lt;&lt; blue &lt;&lt; <span class="stringliteral">&quot;Uppercase: &quot;</span> &lt;&lt; norm &lt;&lt; uppercase &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">   stream &lt;&lt; blue &lt;&lt; <span class="stringliteral">&quot;Lowercase: &quot;</span> &lt;&lt; norm &lt;&lt; lowercase &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">   stream &lt;&lt; blue &lt;&lt; <span class="stringliteral">&quot;Lines: &quot;</span> &lt;&lt; norm &lt;&lt; lines &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">   stream &lt;&lt; blue &lt;&lt; <span class="stringliteral">&quot;Words: &quot;</span> &lt;&lt; norm &lt;&lt; words &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">   stream &lt;&lt; blue &lt;&lt; <span class="stringliteral">&quot;Characters: &quot;</span> &lt;&lt; norm &lt;&lt; chars &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">   <span class="keywordflow">return</span>(stream);</div><div class="line">}</div></div><!-- fragment --><p>All thats left is to define a main class to instantiate everything and a Makefile to run the compilation from the command line (invoked by typing make in the source code directory). Our main class is perhaps a bit more complex than it has to be, however I wanted to include the stream example and the file example all in one, so there is extra code to parse the two flags I added to make this happen. It should be relatively self explanatory for anyone familiar with parsing the argv array.</p>
<p><b>The Main Function</b></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cstring&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;mc_driver.hpp&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> </div><div class="line"><a class="code" href="../../dd/d47/mc__ast__to__dot_8cpp.html#ac762d48b889bd832ec0d42abcbc50624">main</a>( <span class="keyword">const</span> <span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> **argv )</div><div class="line">{</div><div class="line">   <span class="keywordflow">if</span>( argc == 2 )</div><div class="line">   {</div><div class="line">      <a class="code" href="../../d8/dcb/class_m_c_1_1_m_c___driver.html">MC::MC_Driver</a> driver;</div><div class="line">      <span class="keywordflow">if</span>( std::strncmp( argv[ 1 ], <span class="stringliteral">&quot;-o&quot;</span>, 2 ) == 0 )</div><div class="line">      {</div><div class="line">         driver.<a class="code" href="../../d8/dcb/class_m_c_1_1_m_c___driver.html#abe3e374d900420bf84160aed1641217c">parse</a>( std::cin );</div><div class="line">      }</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span>( std::strncmp( argv[ 1 ], <span class="stringliteral">&quot;-h&quot;</span>, 2 ) == 0 )</div><div class="line">      {</div><div class="line">         std::cout &lt;&lt; <span class="stringliteral">&quot;use -o for pipe to std::cin\n&quot;</span>;</div><div class="line">         std::cout &lt;&lt; <span class="stringliteral">&quot;just give a filename to count from a file\n&quot;</span>;</div><div class="line">         std::cout &lt;&lt; <span class="stringliteral">&quot;use -h to get this menu\n&quot;</span>;</div><div class="line">         <span class="keywordflow">return</span>( EXIT_SUCCESS );</div><div class="line">      }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">         driver.<a class="code" href="../../d8/dcb/class_m_c_1_1_m_c___driver.html#abe3e374d900420bf84160aed1641217c">parse</a>( argv[1] );</div><div class="line">      }</div><div class="line">      driver.<a class="code" href="../../d8/dcb/class_m_c_1_1_m_c___driver.html#ab58c2d21dd6ba7d372863efdb24b181f">print</a>( std::cout ) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">   }</div><div class="line">   <span class="keywordflow">else</span></div><div class="line">   {</div><div class="line">      <span class="keywordflow">return</span> ( EXIT_FAILURE );</div><div class="line">   }</div><div class="line">   <span class="keywordflow">return</span>( EXIT_SUCCESS );</div><div class="line">}</div></div><!-- fragment --><p><b>The Makefile</b></p>
<div class="fragment"><div class="line">CC    ?= clang</div><div class="line">CXX   ?= clang++</div><div class="line"></div><div class="line">EXE = my_wc</div><div class="line"></div><div class="line">CDEBUG = -g -Wall</div><div class="line"></div><div class="line">CXXDEBUG = -g -Wall</div><div class="line"></div><div class="line">CSTD = -std=c99</div><div class="line">CXXSTD = -std=c++11</div><div class="line"></div><div class="line">CFLAGS = -Wno-deprecated-<span class="keyword">register</span> -O0  $(CDEBUG) $(CSTD) </div><div class="line">CXXFLAGS = -Wno-deprecated-<span class="keyword">register</span> -O0  $(CXXDEBUG) $(CXXSTD)</div><div class="line"></div><div class="line"></div><div class="line">CPPOBJ = <a class="code" href="../../dd/d47/mc__ast__to__dot_8cpp.html#ac762d48b889bd832ec0d42abcbc50624">main</a> mc_driver</div><div class="line">SOBJ =  parser lexer</div><div class="line"></div><div class="line">FILES = $(addsuffix .cpp, $(CPPOBJ))</div><div class="line"></div><div class="line">OBJS  = $(addsuffix .o, $(CPPOBJ))</div><div class="line"></div><div class="line">CLEANLIST =  $(addsuffix .o, $(OBJ)) $(OBJS) \</div><div class="line">                 mc_parser.tab.cc mc_parser.tab.hh \
                 location.hh position.hh \
                stack.hh mc_parser.output parser.o \
                 lexer.o mc_lexer.yy.cc $(EXE)\</div><div class="line"></div><div class="line">.PHONY: all</div><div class="line">all: wc</div><div class="line"></div><div class="line">wc: $(FILES)</div><div class="line">    $(MAKE) $(SOBJ)</div><div class="line">    $(MAKE) $(OBJS)</div><div class="line">    $(CXX) $(CXXFLAGS) -o $(EXE) $(OBJS) parser.o lexer.o $(LIBS)</div><div class="line"></div><div class="line"></div><div class="line">parser: mc_parser.yy</div><div class="line">    bison -d -v mc_parser.yy</div><div class="line">    $(CXX) $(CXXFLAGS) -c -o parser.o mc_parser.tab.cc</div><div class="line"></div><div class="line">lexer: mc_lexer.l</div><div class="line">    flex --outfile=mc_lexer.yy.cc  $&lt;</div><div class="line">    $(CXX)  $(CXXFLAGS) -c mc_lexer.yy.cc -o lexer.o</div><div class="line"></div><div class="line">.PHONY: test</div><div class="line">test:</div><div class="line">    cd test &amp;&amp; ./test0.pl</div><div class="line"></div><div class="line">.PHONY: clean</div><div class="line">clean:</div><div class="line">    rm -rf $(CLEANLIST)</div></div><!-- fragment --><p>Be aware that some compilers still use the c++0x flag for standard in lieu or the c++11 flag. If you are not using clang as your compiler you should change the appropriate lines within the Makefile so that make will know which compiler to call. The full code is available for download from my git-hub page here: <a href="https://github.com/jonathan-beard/simple_wc_example.git">https://github.com/jonathan-beard/simple_wc_example.git</a> or Zip Download . If you find some errors, feel free to hop on GitHub and correct them!! I'll update the pieces here accordingly. Thanks to all who have contributed to making this as up to date as possible. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
